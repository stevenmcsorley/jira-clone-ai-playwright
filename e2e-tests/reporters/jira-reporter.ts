import { Reporter, FullConfig, Suite, TestCase, TestResult } from '@playwright/test/reporter';
import * as fs from 'fs';
import * as path from 'path';

interface JiraIssue {
  title: string;
  description: string;
  status: 'todo' | 'in_progress' | 'done';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  type: 'task' | 'story' | 'bug' | 'epic';
  projectId: number;
  reporterId: number;
  labels: string[];
}

class JiraReporter implements Reporter {
  private apiUrl: string;
  private projectId: number;
  private reporterId: number;
  private failedTests: Array<{
    test: TestCase;
    result: TestResult;
    error: string;
  }> = [];

  constructor() {
    this.apiUrl = process.env.JIRA_API_URL || 'http://localhost:4000/api';
    this.projectId = parseInt(process.env.JIRA_PROJECT_ID || '1');
    this.reporterId = parseInt(process.env.JIRA_REPORTER_ID || '1');
  }

  onBegin(config: FullConfig, suite: Suite) {
    console.log(`üß™ Starting test run with ${suite.allTests().length} tests`);
    this.failedTests = [];
  }

  onTestEnd(test: TestCase, result: TestResult) {
    if (result.status === 'failed') {
      const error = result.errors[0];
      this.failedTests.push({
        test,
        result,
        error: error?.message || 'Unknown error'
      });
    }
  }

  async onEnd() {
    if (this.failedTests.length === 0) {
      console.log('‚úÖ All tests passed! No bug tickets needed.');
      return;
    }

    console.log(`‚ùå ${this.failedTests.length} test(s) failed. Creating bug tickets...`);

    // Group similar failures
    const groupedFailures = this.groupSimilarFailures(this.failedTests);

    for (const group of groupedFailures) {
      await this.createBugTicket(group);
    }
  }

  private groupSimilarFailures(failures: typeof this.failedTests) {
    // Group failures by test file and error type
    const groups = new Map<string, typeof failures>();

    for (const failure of failures) {
      const testFile = failure.test.location.file;
      const errorType = this.extractErrorType(failure.error);
      const key = `${testFile}:${errorType}`;

      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(failure);
    }

    return Array.from(groups.values());
  }

  private extractErrorType(error: string): string {
    // Extract meaningful error type from error message
    if (error.includes('TimeoutError')) return 'Timeout';
    if (error.includes('expect')) return 'Assertion';
    if (error.includes('locator')) return 'Element not found';
    if (error.includes('network')) return 'Network';
    return 'Unknown';
  }

  private async createBugTicket(failures: typeof this.failedTests) {
    const firstFailure = failures[0];
    const testFile = path.basename(firstFailure.test.location.file);
    const testTitle = firstFailure.test.title;
    const errorType = this.extractErrorType(firstFailure.error);

    // Determine priority based on error type and test importance
    const priority = this.determinePriority(errorType, testTitle);

    const title = `Test Failure: ${testTitle} in ${testFile}`;

    const description = this.buildDescription(failures, errorType);

    const bugTicket: JiraIssue = {
      title,
      description,
      status: 'todo',
      priority,
      type: 'bug',
      projectId: this.projectId,
      reporterId: this.reporterId,
      labels: ['automated-test', 'playwright', `error-${errorType.toLowerCase()}`, testFile.replace('.spec.ts', '')]
    };

    try {
      const response = await fetch(`${this.apiUrl}/issues`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(bugTicket),
      });

      if (response.ok) {
        const createdIssue = await response.json();
        console.log(`üêõ Created bug ticket: ${createdIssue.project?.key}-${createdIssue.id} - ${title}`);

        // Save screenshots and videos as attachments info
        this.saveTestArtifacts(failures, createdIssue.id);
      } else {
        console.error(`‚ùå Failed to create bug ticket: ${response.statusText}`);
      }
    } catch (error) {
      console.error('‚ùå Error creating bug ticket:', error);
    }
  }

  private buildDescription(failures: typeof this.failedTests, errorType: string): string {
    const firstFailure = failures[0];
    const timestamp = new Date().toISOString();

    let description = `# Test Failure Report

**Generated by:** Playwright Automated Testing
**Timestamp:** ${timestamp}
**Error Type:** ${errorType}
**Failed Test Count:** ${failures.length}

## Test Details

**File:** \`${firstFailure.test.location.file}\`
**Test:** ${firstFailure.test.title}
**Line:** ${firstFailure.test.location.line}

## Error Information

\`\`\`
${firstFailure.error}
\`\`\`

## Test Results
`;

    failures.forEach((failure, index) => {
      description += `
### Failure ${index + 1}
- **Duration:** ${failure.result.duration}ms
- **Retry:** ${failure.result.retry}
- **Browser:** ${failure.test.parent.project()?.name || 'Unknown'}

\`\`\`
${failure.error}
\`\`\`
`;
    });

    description += `
## Reproduction Steps

1. Run the test: \`npx playwright test ${path.basename(firstFailure.test.location.file)}\`
2. Check the test output and screenshots in \`test-results/\`
3. Review the application state at the time of failure

## Environment

- **Test Framework:** Playwright
- **Base URL:** ${process.env.BASE_URL || 'http://localhost:5173'}
- **CI Environment:** ${process.env.CI ? 'Yes' : 'No'}

## Artifacts

Screenshots and videos are available in the test results directory for manual review.
`;

    return description;
  }

  private determinePriority(errorType: string, testTitle: string): 'low' | 'medium' | 'high' | 'urgent' {
    // Critical functionality tests
    if (testTitle.toLowerCase().includes('login') ||
        testTitle.toLowerCase().includes('auth') ||
        testTitle.toLowerCase().includes('security')) {
      return 'urgent';
    }

    // Core features
    if (testTitle.toLowerCase().includes('create') ||
        testTitle.toLowerCase().includes('save') ||
        testTitle.toLowerCase().includes('delete')) {
      return 'high';
    }

    // UI/UX issues
    if (errorType === 'Element not found' || errorType === 'Timeout') {
      return 'medium';
    }

    return 'medium';
  }

  private saveTestArtifacts(failures: typeof this.failedTests, issueId: number) {
    // Create a directory for this issue's artifacts
    const artifactDir = path.join('test-results', `issue-${issueId}`);

    if (!fs.existsSync(artifactDir)) {
      fs.mkdirSync(artifactDir, { recursive: true });
    }

    // Save a summary file
    const summary = {
      issueId,
      timestamp: new Date().toISOString(),
      failures: failures.map(f => ({
        test: f.test.title,
        file: f.test.location.file,
        error: f.error,
        duration: f.result.duration,
        retry: f.result.retry,
        attachments: f.result.attachments.map(a => ({
          name: a.name,
          path: a.path,
          contentType: a.contentType
        }))
      }))
    };

    fs.writeFileSync(
      path.join(artifactDir, 'summary.json'),
      JSON.stringify(summary, null, 2)
    );

    console.log(`üìÅ Test artifacts saved to: ${artifactDir}`);
  }
}

export default JiraReporter;