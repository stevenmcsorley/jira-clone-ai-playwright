import { Before, After, BeforeAll, AfterAll, setWorldConstructor } from '@cucumber/cucumber';
import { chromium, Browser, BrowserContext, Page } from '@playwright/test';
import { testConfig } from '../config/test.config';
import { testDataService } from '../services/test-data.service';
import { apiService } from '../services/api.service';
import { ProjectBoardPage } from '../pages/ProjectBoardPage';
import { CreateIssuePage } from '../pages/CreateIssuePage';
import { SprintBoardPage } from '../pages/SprintBoardPage';

export class PlaywrightWorld {
  browser!: Browser;
  context!: BrowserContext;
  page!: Page;

  // Services
  apiService = apiService;
  config = testConfig;

  // Page objects
  projectBoardPage!: ProjectBoardPage;
  createIssuePage!: CreateIssuePage;
  sprintBoardPage!: SprintBoardPage;

  // Test context data
  testContext: Map<string, any> = new Map();

  constructor() {
    // Initialize test context
    this.testContext = new Map();
  }

  async init() {
    // Launch browser
    this.browser = await chromium.launch({
      headless: testConfig.execution.headless,
      slowMo: testConfig.execution.slowMo
    });

    // Create browser context
    this.context = await this.browser.newContext({
      baseURL: testConfig.baseUrl,
      viewport: testConfig.execution.viewport,
      ignoreHTTPSErrors: true
    });

    // Create page
    this.page = await this.context.newPage();

    // Initialize page objects
    this.projectBoardPage = new ProjectBoardPage(this.page);
    this.createIssuePage = new CreateIssuePage(this.page);
    this.sprintBoardPage = new SprintBoardPage(this.page);

    // Set up error logging
    this.page.on('console', msg => {
      if (msg.type() === 'error') {
        console.log(`Console Error: ${msg.text()}`);
      }
    });

    this.page.on('requestfailed', request => {
      console.log(`Request failed: ${request.url()}`);
    });
  }

  async cleanup() {
    if (this.page) {
      await this.page.close();
    }
    if (this.context) {
      await this.context.close();
    }
    if (this.browser) {
      await this.browser.close();
    }
  }

  // Helper methods for test context
  setTestData(key: string, value: any): void {
    this.testContext.set(key, value);
  }

  getTestData(key: string): any {
    return this.testContext.get(key);
  }

  getTestProject(): any {
    return testDataService.getTestProject();
  }

  getTestUser(): any {
    return testDataService.getTestUser();
  }

  setTestSprint(sprint: any): void {
    this.testContext.set('sprint', sprint);
  }

  getTestSprint(): any {
    return this.testContext.get('sprint');
  }

  async createBugTicket(scenarioName: string, errorMessage: string): Promise<void> {
    const timestamp = new Date().toISOString();
    const project = this.getTestProject();
    const user = this.getTestUser();

    const bugTicket = {
      title: `Test Failure: ${scenarioName}`,
      description: `# Automated Test Failure Report

**Generated by:** Cucumber BDD Tests
**Timestamp:** ${timestamp}
**Scenario:** ${scenarioName}
**Project:** ${project.name} (${project.key})

## Error Information

\`\`\`
${errorMessage}
\`\`\`

## Test Context

- **Base URL:** ${testConfig.baseUrl}
- **Test Project ID:** ${project.id}
- **Environment:** ${process.env.NODE_ENV || 'development'}

## Reproduction Steps

1. Run the BDD test: \`npm run test:bdd -- --name "${scenarioName}"\`
2. Check the test output and screenshots in \`test-results/\`
3. Review the application state at the time of failure

## Additional Notes

This bug was automatically created by the test suite when a scenario failed.
Please review the test scenario and fix the underlying issue.
`,
      status: 'todo',
      priority: 'high', // Failed tests are high priority
      type: 'bug',
      projectId: project.id,
      reporterId: user.id,
      labels: ['automated-test', 'cucumber-bdd', 'test-failure']
    };

    try {
      const response = await fetch(`${testConfig.apiUrl}/issues`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(bugTicket),
      });

      if (response.ok) {
        const createdIssue: any = await response.json();
        console.log(`ðŸ› Created bug ticket: ${project.key}-${createdIssue.id} - ${bugTicket.title}`);
      } else {
        console.error(`âŒ Failed to create bug ticket: ${response.statusText}`);
      }
    } catch (error) {
      console.error('âŒ Error creating bug ticket:', error);
    }
  }
}

setWorldConstructor(PlaywrightWorld);

// Global test setup - runs once before all scenarios
BeforeAll(async function() {
  console.log('ðŸš€ Starting E2E test suite...');
  console.log(`ðŸ“ Environment: ${testConfig.baseUrl}`);
  console.log(`ðŸ—ï¸  Test Project: ${testConfig.testProject.name} (${testConfig.testProject.key})`);

  // Initialize test data
  await testDataService.initializeTestData();
});

// Global test cleanup - runs once after all scenarios
AfterAll(async function() {
  console.log('ðŸ E2E test suite completed');

  // Cleanup test data
  await testDataService.cleanupTestData();
});

// Individual test setup - runs before each scenario
Before(async function (this: PlaywrightWorld) {
  await this.init();

  // Set test context from global test data
  const testContext = testDataService.getTestContext();
  this.setTestData('project', testContext.project);
  this.setTestData('user', testContext.testUser);
});

// Individual test cleanup - runs after each scenario
After(async function (this: PlaywrightWorld, { result, pickle }) {
  // Take screenshot on failure
  if (result?.status === 'FAILED') {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    await this.page.screenshot({
      path: `test-results/screenshots/failure-${timestamp}.png`,
      fullPage: true
    });

    // Check if this scenario is tagged for bug reporting
    const shouldCreateBug = pickle.tags.some(tag => tag.name === '@bug-report') ||
                           this.testContext.get('errorEncountered');

    if (shouldCreateBug && result?.exception?.message) {
      await this.createBugTicket(pickle.name, result.exception.message);
    }
  }

  await this.cleanup();
});