Frontend

React + TypeScript (Vite for dev/build). Fast, huge ecosystem, great type safety for complex UIs (boards, forms, inline edits). React/TS is the de-facto modern choice for this kind of app. 
Brisk Tech Solutions

UI: TailwindCSS + component library (Headless UI / Radix) for accessible components.

State & data: React Query (server state) + small client cache like Zustand for local UI state.

Optional: drag-and-drop: @dnd-kit or react-beautiful-dnd for board/card interactions.

Backend

Node.js + TypeScript with NestJS (or Express/Koa if you prefer small). Nest gives structure for APIs, DI, modular services — good for a feature-rich product. If you prefer a non-JS backend, Go (Gin) or Elixir (Phoenix) are excellent alternatives (Elixir especially if you want massive realtime performance). 
DEV Community
+1

Database & search

PostgreSQL as the primary relational DB (issues, projects, users, ACLs). Production-grade, reliable, supports JSONB for flexible fields. 
devayansarkar.medium.com

For advanced search and filters, add Elasticsearch or Meilisearch (Meilisearch is much lighter if you want simple fast text search).

Realtime & notifications

WebSockets (Socket.IO with Node / Phoenix Channels if Elixir) for presence, live issue updates, assignment events. Use server-side broadcast to update clients instantly.

Background jobs / workflows

Redis + BullMQ for background jobs (email, webhooks, heavy index updates). If you want durable workflow orchestration, consider Temporal (overkill initially but great for complex approval/workflow flows).

Auth & SSO

Keycloak (self-hosted) or Auth0/Clerk if managed. Provide OAuth2, SAML, team/space membership and RBAC. Keycloak integrates nicely with Docker.

Use JWTs or session cookies with proper refresh/rotation.

File storage

MinIO (S3-compatible) for attachments, images; easy to run in Docker.

Infrastructure & devops

Local / small deploy: Docker Compose (easy).

Production / scale: Kubernetes (k3s for small clusters) + Traefik or NGINX ingress.

CI/CD: GitHub Actions to build images and push to registry.

Monitoring/logging: Prometheus + Grafana + Sentry for error tracking.

Why these choices

They give a familiar developer DX (TypeScript full-stack optional), predictable performance, and mature integrations (search, redis, s3) you’ll need for features like fast filtering, attachments, notifications and background tasks. Open source alternatives and examples use similar building blocks (Postgres + Redis + React). 
Budibase
+1

Minimal feature design notes (so your clone doesn’t suffer from “Jira confusion”)

Keep issue editing inline and minimal: click-to-edit title/description, less modal-sprawl.

Simple assignment model: single assignee by default + quick reassign action (email + instant notification).

Workflows: start with simple state machine (To Do → In Progress → Done) and provide a workflow editor later. Implement state transitions server-side and validate with a state machine lib (server-side) to avoid inconsistent states.

Bulk actions: multi-select + bulk-change (status, assignee, label) — many users complain when those are absent.

Good defaults and onboarding: minimal fields by default, optional advanced fields.

Docker Compose starter (copy-paste)

Save this as docker-compose.yml. It’s a local dev stack (backend, postgres, redis, minio). Tweak images/versions to taste.

version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: jira_clone
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: jira_clone
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    command: ["redis-server", "--save", "60", "1"]
    volumes:
      - redisdata:/data
    ports:
      - "6379:6379"

  minio:
    image: minio/minio:RELEASE.2025-01-01T00-00-00Z
    environment:
      MINIO_ROOT_USER: minio
      MINIO_ROOT_PASSWORD: minio123
    command: server /data
    ports:
      - "9000:9000"
    volumes:
      - miniodata:/data

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgres://jira_clone:secret@postgres:5432/jira_clone
      REDIS_URL: redis://redis:6379
      MINIO_ENDPOINT: minio:9000
      MINIO_ACCESS_KEY: minio
      MINIO_SECRET_KEY: minio123
      NODE_ENV: development
    depends_on:
      - postgres
      - redis
      - minio
    ports:
      - "4000:4000"
    volumes:
      - ./backend:/usr/src/app

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    environment:
      VITE_API_URL: http://localhost:4000/api
    ports:
      - "5173:5173"
    volumes:
      - ./frontend:/usr/src/app
    depends_on:
      - backend

volumes:
  pgdata:
  redisdata:
  miniodata:


Notes:

Backend: implement REST + GraphQL endpoints (GraphQL is nice for flexible UIs). Serve static assets for production (build frontend → serve via nginx).

Use ENV variables for secrets in production (vault/secret manager).

For production TLS/routing use Traefik as a reverse proxy and Let’s Encrypt for certs.

Alternatives / tradeoffs

If you want massive realtime and soft real-time collaboration (live cursors, super low-latency), Elixir + Phoenix is an excellent choice. If you prefer strict typing everywhere, consider Go backend + gRPC (but more work on frontend integration). 
DEV Community

If you want fewer moving parts, a monolithic Rails app (Redmine-style) or Ruby on Rails can be quicker to prototype (lots of plugins exist). Many open-source Jira-alternatives are Ruby (Redmine) or Python. 
rootstack.com

Roadmap (first 4 milestones)

M0 — Core data model & API: Projects, Issues, Users, Comments, Assignments, Labels, basic auth. (DB schema + REST/GraphQL).

M1 — Frontend CRUD: board/list views, inline edit, create, assign, search.

M2 — Realtime updates, notifications, background processing for emails and webhooks.

M3 — Workflow editor, permissions & roles, attachments (MinIO), full-text search indexing.

Helpful links I used / sources

Open-source Jira alternatives and comparisons (good to see feature tradeoffs). 
Budibase
+1

Practical guides on stacks used for issue trackers (Postgres recommendation). 
devayansarkar.medium.com

Notes on Atlassian/Jira architecture (they use Java/Kotlin services + React on frontend in many places). 
Atlassian Developer
+1